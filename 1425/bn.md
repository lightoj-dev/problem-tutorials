# LOJ 1425- The Monkey and the Oiled Bamboo

ধরুন আপনি কাছে একটা মই আছে সেটা দিয়ে উপরে ওঠা লাগবে কিন্তু উঠার সময় কোন ধাপ বাদ দিতে পারবেন না,
ধাপে ধাপেই উঠতে হবে। এবং আপনাকে একটা এনার্জি দেওয়া আছে যার মান k। মানে আপনি এক লাফে সর্বোচ্চ k পরিমাণ 
উচ্চতায় উঠতে পারবেন। যদি আপনি এক লাফে k উচ্চতায় উঠেন, আপনার k এর মান এক কমে যাবে। 
এ থেকে বোঝা যায় যে আপনি k-1 উচ্চতায় লাফ দিতে পারবেন। আবার k-1 উচ্চতায় লাফ দিলে তারপর 
থেকে k-2 উচ্চতার বেশি লাফাতে পারবেন না। কিন্তু k এর কম উচ্চতায় লাফালে k একই থাকবে। 
আপনাকে ভূমি থেকে মইয়ের প্রতিটা ধাপের উচ্চতা দেওয়া হবে। আপনাকে এমন একটা k বের করতে হবে ।
যা দিয়ে আপনি মইয়ের সবগুলো ধাপ পার করতে পারবেন এবং k এর মান যত সম্ভব ছোট হতে হবে।

সমাধানঃ

আমরা এই সমস্যাটি সমাধান করতে ডিফারেন্স  অ্যারে ব্যবহার করে করতে পারি। 
প্রথমে আমরা দুটি ইন্ডেক্স এর ডিফারেন্স নিয়ে একটা এরে তৈরি করি।
তারপরে ডিফারেন্স  অ্যারে টিকে আমরা ছোট থেকে বড় আকারে সাজিয়ে রাখতে পারি এবং সর্বাধিক বড় মানটি একটি ভেরিয়েবলের মধ্যে  রেখে সেই মান দিয়ে আমরা আমাদের সমাধানের পথে আগাতে পারি যেমন: int a = diff [lastPostion-1] -1;
সর্বোপরি পুরো অ্যারেটি  লাস্ট থেকে চেক  করতে থাকি  এবং এই মানটি যদি ডিফারেন্স এরেটির মানের সমান হয় তবে a এর মান ১ কমাতে থাকি,  অন্যথায় লুপটি ব্রেক করে দিতে পারি।
যদি ডিফারেন্স এরেটির প্রতিটির ভ্যালুর ডিফারেন্স ১ হয় তাহলে শেষ পর্যন্ত ডিফারেন্স এরের লাস্ট ভ্যালুটিই উত্তর অন্যথায় লাস্ট ভ্যালুটির সাথে ১ যোগ করলেই আমরা উত্তর পেতে পারি । 

আশা করি সমস্যাটা বোঝা গেছে।

আপনি যদি এখনও এই সমস্যায় আটকে থাকেন তবে নীচের কোডগুলি দেখুন:

### C++ 

```c++
#include<bits/stdc++.h>
#define fr(i1,m) for(int i1=0;i1<m;i1++)
using namespace std;
int main()
{
    long n,m;
    cin>>n;
    fr(i1,n)
    {
        long a[100000]= {0},tt=0,i,j,c=0,x,k,l,p=1,b[100000]= {0};
        cin>>m;
        fr(i,m)
        cin>>a[i];
        b[0]=a[0];
        for(i=1; i<m; i++)
        {
            b[p++]=a[i]-a[i-1];
        }
        sort(b,b+p);
        x=b[p-1]-1;
        for(i=p-2; i>=0; i--)
        {
            if(x==b[i])
                x--;
            else if(x<b[i])
            {
                tt=1;
                break;
            }
        }
        if(tt==1)
        {
            printf("Case %ld: %ld\n",i1+1,b[p-1]+1);
        }
        else
            printf("Case %ld: %ld\n",i1+1,b[p-1]);

    }
    return 0;
}
```