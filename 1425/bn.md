# LOJ 1425- The Monkey and the Oiled Bamboo

ধরুন আপনি কাছে একটা মই আছে সেটা দিয়ে উপরে ওঠা লাগবে কিন্তু উঠার সময় কোন ধাপ বাদ দিতে পারবেন না,
ধাপে ধাপেই উঠতে হবে। এবং আপনাকে একটা এনার্জি দেওয়া আছে যার মান k। মানে আপনি এক লাফে সর্বোচ্চ k পরিমাণ 
উচ্চতায় উঠতে পারবেন। যদি আপনি এক লাফে k উচ্চতায় উঠেন, আপনার k এর মান এক কমে যাবে। 
এ থেকে বোঝা যায় যে আপনি k-1 উচ্চতায় লাফ দিতে পারবেন। আবার k-1 উচ্চতায় লাফ দিলে তারপর 
থেকে k-2 উচ্চতার বেশি লাফাতে পারবেন না। কিন্তু k এর কম উচ্চতায় লাফালে k একই থাকবে। 
আপনাকে ভূমি থেকে মইয়ের প্রতিটা ধাপের উচ্চতা দেওয়া হবে। আপনাকে এমন একটা k বের করতে হবে ।
যা দিয়ে আপনি মইয়ের সবগুলো ধাপ পার করতে পারবেন এবং k এর মান যত সম্ভব ছোট হতে হবে।

সমাধানঃ

আমরা এই সমস্যাটি সমাধান করতে ডিফারেন্স  অ্যারে ব্যবহার করে করতে পারি। 
প্রথমে আমরা দুটি ইন্ডেক্স এর ডিফারেন্স নিয়ে একটা এরে তৈরি করি।
তারপরে ডিফারেন্স  অ্যারে টিকে আমরা ছোট থেকে বড় আকারে সাজিয়ে রাখতে পারি এবং সর্বাধিক বড় মানটি একটি ভেরিয়েবলের মধ্যে  রেখে সেই মান দিয়ে আমরা আমাদের সমাধানের পথে আগাতে পারি যেমন: int a = diff [lastPostion-1] -1;
সর্বোপরি পুরো অ্যারেটি  লাস্ট থেকে চেক  করতে থাকি  এবং এই মানটি যদি ডিফারেন্স এরেটির মানের সমান হয় তবে a এর মান ১ কমাতে থাকি,  অন্যথায় লুপটি ব্রেক করে দিতে পারি।
যদি ডিফারেন্স এরেটির প্রতিটির ভ্যালুর ডিফারেন্স ১ হয় তাহলে শেষ পর্যন্ত ডিফারেন্স এরের লাস্ট ভ্যালুটিই উত্তর অন্যথায় লাস্ট ভ্যালুটির সাথে ১ যোগ করলেই আমরা উত্তর পেতে পারি । 

আশা করি সমস্যাটা বোঝা গেছে।

আপনি যদি এখনও এই সমস্যায় আটকে থাকেন তবে নীচের কোডগুলি দেখুন:

### C++ 

```c++
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,m;
    cin>>n;
    for(int i1=0;i1<n;i1++)
    {
        int a[100000]= {0},tt=0,i,j,c=0,x,k,l,p=1,b[100000]= {0};
        cin>>m;
        for(i=0;i<m;i++)
			cin>>a[i];
        b[0]=a[0];
        for(i=1; i<m; i++)
        {
            b[p++]=a[i]-a[i-1];
        }
        sort(b,b+p);
        x=b[p-1]-1;
        for(i=p-2; i>=0; i--)
        {
            if(x==b[i])
                x--;
            else if(x<b[i])
            {
                tt=1;
                break;
            }
        }
        if(tt==1)
        {
            printf("Case %ld: %ld\n",i1+1,b[p-1]+1);
        }
        else
            printf("Case %ld: %ld\n",i1+1,b[p-1]);

    }
    return 0;
}
```