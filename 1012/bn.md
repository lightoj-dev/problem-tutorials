# ক্যাটাগরি : ডি এফ এস 

### প্রশ্নে কি জিজ্ঞেস করেছে ? 

কাহিনীর অর্থে : একজন রাজা তার ছেলেকে রাজ্য ছাড়তে বলেন । পুত্র উনার কথা মান্য করে রাজ্য ছাড়ে । পরবর্তীতে রাজকুমার এমন একটি জায়গায় যান যেখানে প্রতিটি অঞ্চল হয় পানিতে পূর্ণ 
অথবা জমিন । রাজকুমার জানতে চান উনার জায়গা হতে কতগুলা জমিন এ উনি যেতে পারবেন 

গাণিতিক অর্থে : একটি nxm গ্রিড দেয়া থাকবে । একটি পজিশন '@' দেয়া  থাকবে যে জায়গা থেকে শুরু করে কয়টি সেল এ যেতে পারবো ? একটা সেল থেকে অন্য সেল এ যাওয়া যাবে যদি সেল টি তে '.' থাকে | আমরা কোন সেল এ '#' থাকলে যেতে পারবো না 

### যা যা শিখা উচিত এইটা করার আগে : 
১ [ডি এফ এস  ](http://www.shafaetsplanet.com/?p=973 ) (এটি বি এফ এস দিয়ে ও করা যাবে ) 

## সমাধান 

আমরা প্রথমে একটি nxm ক্যারেক্টার অ্যারে তে আমাদের পুরো গ্রিড স্টোর করবো 
নিচের উদাহরণ এর মত একটি 2D অ্যারে তে আমরা ক্যারেক্টার গুলা নিব  

![alt text](https://user-images.githubusercontent.com/72943111/202870913-02f03555-4222-4eed-a889-b6aee8117c38.png)


প্রতিটি সেল সারি x এবং কলাম y নির্দেশ করে । সমস্যাটি হিসাবে  একটি ঘর থেকে তার সংলগ্ন বাম, ডান, উপরে এবং নীচের ঘরে  যেতে পারি। তাই একটি ঘর থেকে তার সংলগ্ন ঘরে যেতে আমাদের নিম্ন বর্ণিত কাজ  করতে হবে:

```
Left - (x-1,y)
Right - (x+1,y)
Up - (x,y-1)
Down - (x,y+1)
```

প্রতিবার ম্যানুয়ালি এটি করার পরিবর্তে আমরা ডিরেকশনাল অ্যারে ব্যবহার করতে পারি এবং লুপ এর সাহায্যে তা ট্রাভেরস করতে পারি 

```
int dx[]={+1,-1,+0,-0}
int dy[]={+0,-0,+1,-1}
```

এখন প্রারম্ভিক বিন্দু @ থেকে, আমরা প্রতিটি সংলগ্ন কোষে যাই এবং এটি একটি বৈধ সেল কিনা তা পরীক্ষা করি। আমাদের মনে রাখতে হবে যে আমরা গ্রিড এর বাইরে , ওয়াটার সেল # এবং যে কোষগুলি আগে পরিদর্শন করেছি ঐগুলা তে যেতে পারবো না । এটি  আমরা চেক করার জন্য একটি  ফাংশন লিখতে পারি। 
```
bool valid(int x,int y)
{
    if(x>=0 && x<h && y>=0 && y<w && str[x][y]!='#' && !vis[x][y]) return true;
    return false;
}
```

আমরা কতগুলি কোষ পরিদর্শন করতে পারি তা ট্র্যাক করার জন্য আমরা একটি কাউন্টার রাখতে হবে 

### কিছু সতর্কতা
প্রতি কেস এর পর vis এবং cnt ক্লিয়ার করতে হবে 

## সম্পূর্ণ কোড 
```
#include<bits/stdc++.h>
using namespace std;
char A[21][21];
int cnt=0,vis[21][21],n,m;
void dfs(int x,int y)
{
    if(x==n || y==m ||x==-1 || y==-1)
        return;
    if(vis[x][y]==1)
        return ;
    if(A[x][y]=='#')
        return ;
    cnt++;
    vis[x][y]=1;
    dfs(x+1,y);
    dfs(x,y+1);
    dfs(x-1,y);
    dfs(x,y-1);
}
int main()
{
    int t,tes=1;
    cin>>t;
    while(t--)
    {
        int x,y;
        cin>>m>>n;
        string s;
        for(int i=0; i<n; i++)
        {
            cin>>s;
            for(int j=0; j<s.size(); j++)
            {
                A[i][j]=s[j];
                if(A[i][j]=='@')
                {
                    x=i;
                    y=j;
                }
            }
        }
        dfs(x,y);
        cout<<"Case "<<tes<<": "<<cnt<<endl;
        cnt=0;
        memset(vis,0,sizeof(vis));
        tes++;
    }
}


```
